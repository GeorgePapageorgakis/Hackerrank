/*
Given a time range during which the Java Random generator was seeded and the last ten output values of random.nextInt(1000), guess the next value to be output by the generator.

Input Format:
	First line of input contains a number N<10 indicating the number of test cases to follow.
	For each of the N test cases, a line will follow containing two space separated Unix timestamps representing the time during which the random number generator instance was created. The range between the two timestamps will be, at most, 1 000 000.
	The following ten lines contain the first ten numbers sequentially generated by the same Random instance's nextInt(1000) function, one on each line.

Output Format:
	For each test case, output a line containing the seed used to create the generator and the next 10 integers that are output from random.nextInt(1000), separated by spaces.

This is base on a Java random number (int) generator implementation for C++
*/
#include <vector>
#include <iostream>
#include <exception>
#include <stdexcept>
#include <atomic>
using namespace std;

/**
An instance of this class is used to generate a stream of pseudorandom numbers. The class uses a 48-bit seed, which is modified using a linear congruential formula. (See Donald Knuth, The Art of Computer Programming, Volume 3, Section 3.2.1.)

If two instances of Random are created with the same seed, and the same sequence of method calls is made for each, they will generate and return identical sequences of numbers. In order to guarantee this property, particular algorithms are specified for the class Random. Java implementations must use all the algorithms shown here for the class Random, for the sake of absolute portability of Java code. However, subclasses of class Random are permitted to use other algorithms, so long as they adhere to the general contracts for all the methods.

The algorithms implemented by class Random use a protected utility method that on each invocation can supply up to 32 pseudorandomly generated bits.

Many applications will find the method java.lang.Math.random() simpler to use. 
*/
class Random{
    private:
		//use serialVersionUID from JDK 1.1 for interoperability
        //static const long long serialVersionUID = 3905348978240129619L;
		//The internal state associated with this pseudorandom number generator. (The specs for the methods in this class describe the ongoing computation of this value.) 
		std::atomic<long long> seed;
        static constexpr const long long multiplier = 0x5DEECE66DL;
        static constexpr const long long addend = 0xBL;
        static constexpr const long long mask = (1L << 48) - 1;
        long long seedUniquifier = 8682522807148012L;

	public:
		//Creates a new random number generator. This constructor sets the seed of the random number generator to a value very likely to be distinct from any other invocation of this constructor. 
        Random() {
            this->seedUniquifier += 1 + time(NULL);
            this->seed.store(seedUniquifier);
        }
		/*Creates a new random number generator using a single long seed. The seed is the initial value of the internal state of the pseudorandom number generator which is maintained by method next(int).
		The invocation new Random(seed) is equivalent to:
		Random rnd = new Random();
		rnd.setSeed(seed);
		*/
        Random(long long seed) {
            this->seed.store(0L);
            setSeed(seed);
        }
		
		/*Sets the seed of this random number generator using a single long seed. The general contract of setSeed is that it alters the state of this random number generator object so as to be in exactly the same state as if it had just been created with the argument seed as a seed. The method setSeed is implemented by class Random by atomically updating the seed to
			(seed ^ 0x5DEECE66DL) & ((1L << 48) - 1)
		and clearing the haveNextNextGaussian flag used by nextGaussian().
		The implementation of setSeed by class Random happens to use only 48 bits of the given seed. In general, however, an overriding method may use all 64 bits of the long argument as a seed value. 
		*/
        void setSeed(long long seed) {
            seed = (seed ^ multiplier) & mask;
            this->seed.store(seed);
        }
		
		/*Generates the next pseudorandom number. Subclasses should override this, as this is used by all other methods.

		The general contract of next is that it returns an int value and if the argument bits is between 1 and 32 (inclusive), then that many low-order bits of the returned value will be (approximately) independently chosen bit values, each of which is (approximately) equally likely to be 0 or 1. The method next is implemented by class Random by atomically updating the seed to
			(seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1)
		and returning
			(int)(seed >>> (48 - bits)).
		This is a linear congruential pseudorandom number generator, as defined by D. H. Lehmer and described by Donald E. Knuth in The Art of Computer Programming, Volume 3: Seminumerical Algorithms, section 3.2.1.
		*/
        int nextInt() {
			return next(32);
		}
		int nextInt(int n) {
			if (n <= 0)
				throw new std::invalid_argument("n must be positive");
			if ((n & -n) == n)  // i.e., n is a power of 2
				return static_cast<int>((n * static_cast<long long>(next(31))) >> 31);
			int bits, val;
			do {
				bits = next(31);
				val = bits % n;
			} while (bits - val + (n-1) < 0);
			return val;
		}

	protected:
		int next(int bits) {
			long long oldseed, nextseed;
            std::atomic<long long>& seed = this->seed;
            do{
                oldseed = seed.load();
                nextseed = (oldseed * multiplier + addend) & mask;
			} while (!seed.compare_exchange_weak(oldseed, nextseed));
			return static_cast<int>(nextseed >> (48 - bits));
		}
};


void PRNGsequence(pair<int, int>& timeRange, vector<int>& randNums){
    Random ran(timeRange.first);

    for (int seed=timeRange.first; seed<timeRange.second+1; ++seed){
        bool seqFound = true;
        ran.setSeed(seed);

        for (int j = 0; j < randNums.size(); ++j) {
            if (ran.nextInt(1000) != randNums[j]) {
                seqFound = false;
                break;
            }
        }
        if (seqFound) {
            cout << seed << " ";
            for (int k = 0; k < 10; ++k) {
                cout << ran.nextInt(1000) << " ";
            }
            cout << endl;
        }
    }
    return;
}

int main() {
    vector<int> randNums;
    int n;

    cin >> n;
    randNums.resize(10);
    for (int i=0; i<n; ++i){
        pair<int, int> timeRange;

        
        cin >> timeRange.first >> timeRange.second;
        for (int j=0; j<10; ++j){
            cin >> randNums[j];
        }
        //Calculate the next PRNG sequence
        PRNGsequence(timeRange, randNums);
    }
    return 0;
}
